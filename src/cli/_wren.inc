// Generated automatically from src/cli/*.wren. Do not edit.
static const char* resolverModuleSource =
"class Resolver {\n"
"  // this is called at the end of this script when the CLI starts up\n"
"  // and the Resolver VM is fired up\n"
"  static boot() {\n"
"    __modules = {}\n"
"  }\n"
"  static DEBUG { false }\n"
"  static debug(s) { \n"
"    if (this.DEBUG) System.print(s) \n"
"  }\n"
"  // load a dynamic library\n"
"  static loadLibrary(name, file, root) {\n"
"    debug(\"loadLibrary(`%(name)`, `%(file)`, `%(root)`)\")\n"
"    var libPath\n"
"    var moduleDirectories = findModulesDirectories(root)\n"
"    if (moduleDirectories.isEmpty) {\n"
"      Fiber.abort(\"dynamic libraries require a wren_modules folder\")\n"
"    }\n"
"    for (moduleDirectory in moduleDirectories ) {\n"
"      debug(\" - searching %(moduleDirectory)\")\n"
"      libPath = Path.new(moduleDirectory).join(file).toString\n"
"      if (File.existsSync(libPath)) {\n"
"        debug(\" - loading dynamic library `%(file)`\")\n"
"        File.loadDynamicLibrary(name, libPath)\n"
"        return\n"
"      }\n"
"    }\n"
"    Fiber.abort(\" # dynamic library `%(name)` - `%(file)` not found\")\n"
"  }\n"
"  static isLibrary(module) { module.contains(\":\") }\n"
"  // Applies the CLI's import resolution policy. The rules are:\n"
"  //\n"
"  // * If [module] starts with \"./\" or \"../\", it is a relative import, relative\n"
"  //   to [importer]. The resolved path is [name] concatenated onto the directory\n"
"  //   containing [importer] and then normalized.\n"
"  //\n"
"  //   For example, importing \"./a/./b/../c\" from \"./d/e/f\" gives you \"./d/e/a/c\".\n"
"  static resolveModule(importer, module, rootDir) {\n"
"    debug(\"resolveModule(`%(importer)`, `%(module)`, `%(rootDir)`)\")\n"
"    if (isLibrary(module)) {\n"
"      var pieces = module.split(\":\")\n"
"      module = pieces[1]\n"
"      var libraryName = pieces[0]\n"
"      // TODO: linux, windows, etc.\n"
"      var libraryFile = \"lib%(pieces[0]).dylib\"\n"
"      loadLibrary(libraryName, libraryFile, rootDir)\n"
"      return module\n"
"    }\n"
"    // System.print(\"importer: %(importer)  module: %(module)\")\n"
"    if (PathType.resolve(module) == PathType.SIMPLE) return module\n"
"\n"
"    debug(\"dirname: %(Path.new(importer).dirname)\")\n"
"    var path = Path.new(importer).dirname.join(module)\n"
"    debug(\"resolved: %(path.toString)\")\n"
"    return path.toString\n"
"  }\n"
"\n"
"  // walks the tree starting with current root and attemps to find \n"
"  // `wren_modules` which will be used to resolve modules in addition\n"
"  // to built-in modules\n"
"  static findModulesDirectories(root) {\n"
"    // switch to using absolute pathss\n"
"    root = File.realPathSync(root)\n"
"    if (__modules[root]) return __modules[root]\n"
"    var moduleCollections = []\n"
"\n"
"    var path = Path.new(root + \"/\")\n"
"    while(true) {\n"
"      var modules = path.join(\"wren_modules/\").toString \n"
"      debug(\" ? checking for existance: %(modules)\")\n"
"      if (File.existsSync(modules)) {\n"
"        debug(\"- found modules in %(modules)\")\n"
"        // return modules\n"
"        moduleCollections.add(modules)\n"
"      }\n"
"      if (path.isRoot) break\n"
"      path = path.up()\n"
"    }\n"
"    __modules[root] = moduleCollections\n"
"    return moduleCollections\n"
"  }\n"
"\n"
"  // searches for a module inside `wren_modules`\n"
"  //\n"
"  // If the module is a single bare name, treat it as a module with the same\n"
"  // name inside the package. So \"foo\" means \"foo/foo\".\n"
"  //\n"
"  // returns the path to the .wren file that needs to be loaded\n"
"  static findModule(root, module) {\n"
"    var segment\n"
"    if (module.contains(\"/\")) {\n"
"      segment = \"%(module).wren\"\n"
"    } else {\n"
"      segment = \"%(module)/%(module).wren\"\n"
"    }\n"
"    var moduleDirectory = Path.new(root).join(segment).toString\n"
"    debug(\"trying: %(moduleDirectory)\")\n"
"    if (File.existsSync(moduleDirectory)) {\n"
"      debug(\"found module: %(moduleDirectory)\")\n"
"      return moduleDirectory\n"
"    }\n"
"  }\n"
"\n"
"  // Attempts to find the source for [module] relative to the current root\n"
"  // directory.\n"
"  //\n"
"  // Returns the filename to load if found, or `:%(module)` if not which\n"
"  // is the pattern C uses to attempt a built-in module load, ie:\n"
"  // returning `:os` will instruct C to use the internal `os` module.\n"
"  static loadModule(module, rootDir) {\n"
"    debug(\"loadModule(%(module), %(rootDir)\")\n"
"    var type = PathType.resolve(module)\n"
"    debug(type)\n"
"    if (type == PathType.ABSOLUTE || type == PathType.RELATIVE) {\n"
"      var path = \"%(module).wren\"\n"
"      return path\n"
"    }\n"
"\n"
"    var root = File.realPathSync(rootDir)\n"
"    debug(\"root: %(root)\")\n"
"    for (wren_modules in findModulesDirectories(root)) {\n"
"      var loc = findModule(wren_modules, module)\n"
"      if (loc!=null) {\n"
"        debug(\"found %(module) in %(wren_modules)\")\n"
"        return loc\n"
"      }\n"
"    }\n"
"    debug(\"must be built-in? returning :%(module)\")\n"
"    // must be built-in\n"
"    return \":%(module)\"\n"
"  }\n"
"}\n"
"\n"
"class File {\n"
"  foreign static loadDynamicLibrary(name, path)\n"
"  foreign static existsSync(s)\n"
"  foreign static realPathSync(s)\n"
"}\n"
"\n"
"Resolver.boot()\n"
"\n"
"\n"
"\n\n"
"//module=resolver,cli\n"
"class PathType {\n"
"  static SIMPLE { 1 }\n"
"  static ABSOLUTE { 2 }\n"
"  static RELATIVE { 3 }\n"
"\n"
"  static unixAbsolute(path) { path.startsWith(\"/\") }\n"
"  static windowsAbsolute(path) {\n"
"    // TODO: is this not escaped properly by the stock Python code generator\n"
"    return path.count >= 3 && path[1..2] == \":\\\\\"\n"
"  }\n"
"  static resolve(path) {\n"
"    if (path.startsWith(\".\")) return PathType.RELATIVE\n"
"    if (unixAbsolute(path)) return PathType.ABSOLUTE\n"
"    if (windowsAbsolute(path)) return PathType.ABSOLUTE\n"
"\n"
"    return PathType.SIMPLE\n"
"  }\n"
"}\n"
"\n\n"
"//module=resolver,cli\n"
"class Path {\n"
"  construct new(path) { \n"
"    _path = path \n"
"    _sep = appearsWindows() ? \"\\\\\" : \"/\"\n"
"  }\n"
"  appearsWindows() {\n"
"    if (_path.contains(\"\\\\\")) return true\n"
"    if (_path.count>=2 && _path[1] == \":\") return true\n"
"  }\n"
"  sep { _sep || \"/\" }\n"
"  toString { _path }\n"
"  up() { join(\"..\") }\n"
"  join(path) { Path.new(_path + sep + path).normalize }\n"
"  isRoot { \n"
"    return _path == \"/\"  || \n"
"      // C:\n"
"      (_path.count == 2 && _path[1] == \":\") ||\n"
"      // F:\\\n"
"      (_path.count == 3 && _path[1..2] == \":\\\\\") \n"
"  }\n"
"  dirname {\n"
"    if (_path==\"/\") return this\n"
"    if (_path.endsWith(sep)) return Path.new(_path[0..-2])\n"
"    return up()\n"
"  }\n"
"  static split(path) {\n"
"    var segments = []\n"
"    var last = 0\n"
"    var i = 0\n"
"    while (i < path.count) {\n"
"      var char = path[i]\n"
"      if (char == \"/\" || char == \"\\\\\") {\n"
"        if (last==i) {\n"
"          segments.add(\"\")\n"
"        } else {\n"
"          segments.add(path[last...i])\n"
"        }\n"
"        last = i + 1\n"
"      }\n"
"      i = i + 1\n"
"    }\n"
"    if (last<path.count) {\n"
"      segments.add(path[last..-1])\n"
"    } else if (last==i) {\n"
"      segments.add(\"\")\n"
"    }\n"
"    return segments\n"
"  }\n"
"  normalize {\n"
"    // var paths = _path.split(sep)\n"
"    var paths = Path.split(_path)\n"
"    var finalPaths = []\n"
"    if (_path.startsWith(\"/\")) finalPaths.add(\"/\") \n"
"    if (paths[0]==\".\") finalPaths.add(\".\") \n"
"    for (path in paths) {\n"
"      var last = finalPaths.count>0 ? finalPaths[-1] : null\n"
"      if (path == \"..\") {\n"
"        if (last == \"/\") continue\n"
"\n"
"        if (last == \".\")  {\n"
"          finalPaths[-1] = \"..\"\n"
"        } else if (last == \"..\" || last == null) {\n"
"          finalPaths.add(\"%(path)\")  \n"
"        } else {\n"
"          if (finalPaths.count > 0) finalPaths.removeAt(finalPaths.count - 1)\n"
"        }\n"
"      } else if (path == \"\" || path == \".\") {\n"
"        continue\n"
"      } else {\n"
"        finalPaths.add(path)\n"
"      }\n"
"    }\n"
"    if (finalPaths.count>1 && finalPaths[0] == \"/\") finalPaths[0] = \"\"\n"
"    var path = finalPaths.join(sep)\n"
"    if (path == \"\") path = \".\"\n"
"    return Path.new(path)\n"
"  }\n"
"}";

// Generated automatically from src/cli/*.wren. Do not edit.
static const char* cliModuleSource =
"//module=resolver,cli\n"
"class PathType {\n"
"  static SIMPLE { 1 }\n"
"  static ABSOLUTE { 2 }\n"
"  static RELATIVE { 3 }\n"
"\n"
"  static unixAbsolute(path) { path.startsWith(\"/\") }\n"
"  static windowsAbsolute(path) {\n"
"    // TODO: is this not escaped properly by the stock Python code generator\n"
"    return path.count >= 3 && path[1..2] == \":\\\\\"\n"
"  }\n"
"  static resolve(path) {\n"
"    if (path.startsWith(\".\")) return PathType.RELATIVE\n"
"    if (unixAbsolute(path)) return PathType.ABSOLUTE\n"
"    if (windowsAbsolute(path)) return PathType.ABSOLUTE\n"
"\n"
"    return PathType.SIMPLE\n"
"  }\n"
"}\n"
"\n\n"
"import \"repl\" for Repl, AnsiRepl, SimpleRepl\n"
"import \"os\" for Platform, Process\n"
"import \"io\" for Stdin, Stderr, File, Stdout, Stat\n"
"import \"mirror\" for Mirror\n"
"import \"meta\" for Meta\n"
"import \"runtime\" for Runtime\n"
"\n"
"class StackTrace {\n"
"  construct new(fiber) {\n"
"    _fiber = fiber\n"
"    _trace = Mirror.reflect(fiber).stackTrace\n"
"  }\n"
"  print() {\n"
"    Stderr.print(_fiber.error)\n"
"    var out = _trace.frames.map { |f|\n"
"        return \"at %( f.methodMirror.signature ) (%( f.methodMirror.moduleMirror.name ) line %( f.line ))\"\n"
"    }.join(\"\\n\")\n"
"    Stderr.print(out)\n"
"  }\n"
"}\n"
"\n"
"class CLI {\n"
"  static start() {\n"
"    // TODO: pull out argument processing into it's own class\n"
"    if (Process.allArguments.count >=2) {\n"
"      var flag = Process.allArguments[1]\n"
"      if (flag == \"--version\" || flag == \"-v\") {\n"
"        showVersion()\n"
"        return\n"
"      }\n"
"      if (flag == \"--help\" || flag == \"-h\") {\n"
"        showHelp()\n"
"        return\n"
"      }\n"
"      if (flag == \"-e\" && Process.allArguments.count >= 3) {\n"
"        var code = Process.allArguments[2]\n"
"        runCode(code,\"<eval>\")\n"
"        return\n"
"      }\n"
"    }\n"
"\n"
"    if (Process.allArguments.count == 1) {\n"
"      repl()\n"
"    } else {\n"
"      runFile(Process.allArguments[1])\n"
"    }\n"
"    Stdout.flush()\n"
"  }\n"
"  static versionInfo { \"wrenc v%(Runtime.VERSION) (wren v%(Runtime.WREN_VERSION))\" }\n"
"  static showVersion() {\n"
"    System.print(versionInfo) \n"
"  }\n"
"  static showHelp() {\n"
"    System.print(\"Usage: wrenc [file] [arguments...]\")\n"
"    System.print(\"\")\n"
"    System.print(\"Optional arguments:\")\n"
"    System.print(\"  -                read script from stdin\")\n"
"    System.print(\"  -h, --help       print wrenc command line options\")\n"
"    System.print(\"  -v, --version    print wrenc and Wren version\")\n"
"    System.print(\"  -e '[code]'      evaluate code\")\n"
"    System.print()\n"
"    System.print(\"Documentation can be found at https://github.com/joshgoebel/wren-console\")\n"
"    \n"
"  }\n"
"  static dirForModule(file) {\n"
"    return Path.new(file).dirname.toString\n"
"  }\n"
"  static missingScript(file) {\n"
"    Stderr.print(\"wrenc: No such file -- %(file)\")\n"
"  }\n"
"  static runCode(code,moduleName) {\n"
"    var fn = Meta.compile(code,moduleName)\n"
"    if (fn != null) {\n"
"      var fb = Fiber.new (fn)\n"
"      fb.try()\n"
"      if (fb.error) {\n"
"        StackTrace.new(fb).print()\n"
"        Process.exit(70)\n"
"      }\n"
"    } else {\n"
"      Process.exit(65)\n"
"    }\n"
"  }\n"
"  static runInput() {\n"
"    var code = \"\"\n"
"    while(!Stdin.isClosed) code = code + Stdin.read()\n"
"    runCode(code,\"(script)\")\n"
"    return\n"
"  }\n"
"  static runFile(file) {\n"
"    var moduleName\n"
"\n"
"    if (file == \"-\") return runInput()\n"
"    if (!File.exists(file)) return missingScript(file)\n"
"    \n"
"    if (PathType.resolve(file) == PathType.ABSOLUTE) {\n"
"      moduleName = file\n"
"    } else {\n"
"      moduleName = \"./\" + file\n"
"    }\n"
"    \n"
"    var code = File.read(file)\n"
"    setRootDirectory_(dirForModule(moduleName))\n"
"    // System.print(moduleName)\n"
"    runCode(code,moduleName)\n"
"  }\n"
"  static repl() {\n"
"    System.print(\"\"\" -\"\\//\"\"\")\n"
"    System.print(\"  \\\\_/    \\n%(versionInfo) (based on wren-cli@9c6b6933722)\") \n"
"    // \" fix broken VS Code highlighting (not understaning escapes)\n"
"\n"
"    Repl.start()\n"
"  }\n"
"  foreign static setRootDirectory_(dir) \n"
"}\n"
"// CLI.start()\n"
"\n"
"\n\n"
"//module=resolver,cli\n"
"class Path {\n"
"  construct new(path) { \n"
"    _path = path \n"
"    _sep = appearsWindows() ? \"\\\\\" : \"/\"\n"
"  }\n"
"  appearsWindows() {\n"
"    if (_path.contains(\"\\\\\")) return true\n"
"    if (_path.count>=2 && _path[1] == \":\") return true\n"
"  }\n"
"  sep { _sep || \"/\" }\n"
"  toString { _path }\n"
"  up() { join(\"..\") }\n"
"  join(path) { Path.new(_path + sep + path).normalize }\n"
"  isRoot { \n"
"    return _path == \"/\"  || \n"
"      // C:\n"
"      (_path.count == 2 && _path[1] == \":\") ||\n"
"      // F:\\\n"
"      (_path.count == 3 && _path[1..2] == \":\\\\\") \n"
"  }\n"
"  dirname {\n"
"    if (_path==\"/\") return this\n"
"    if (_path.endsWith(sep)) return Path.new(_path[0..-2])\n"
"    return up()\n"
"  }\n"
"  static split(path) {\n"
"    var segments = []\n"
"    var last = 0\n"
"    var i = 0\n"
"    while (i < path.count) {\n"
"      var char = path[i]\n"
"      if (char == \"/\" || char == \"\\\\\") {\n"
"        if (last==i) {\n"
"          segments.add(\"\")\n"
"        } else {\n"
"          segments.add(path[last...i])\n"
"        }\n"
"        last = i + 1\n"
"      }\n"
"      i = i + 1\n"
"    }\n"
"    if (last<path.count) {\n"
"      segments.add(path[last..-1])\n"
"    } else if (last==i) {\n"
"      segments.add(\"\")\n"
"    }\n"
"    return segments\n"
"  }\n"
"  normalize {\n"
"    // var paths = _path.split(sep)\n"
"    var paths = Path.split(_path)\n"
"    var finalPaths = []\n"
"    if (_path.startsWith(\"/\")) finalPaths.add(\"/\") \n"
"    if (paths[0]==\".\") finalPaths.add(\".\") \n"
"    for (path in paths) {\n"
"      var last = finalPaths.count>0 ? finalPaths[-1] : null\n"
"      if (path == \"..\") {\n"
"        if (last == \"/\") continue\n"
"\n"
"        if (last == \".\")  {\n"
"          finalPaths[-1] = \"..\"\n"
"        } else if (last == \"..\" || last == null) {\n"
"          finalPaths.add(\"%(path)\")  \n"
"        } else {\n"
"          if (finalPaths.count > 0) finalPaths.removeAt(finalPaths.count - 1)\n"
"        }\n"
"      } else if (path == \"\" || path == \".\") {\n"
"        continue\n"
"      } else {\n"
"        finalPaths.add(path)\n"
"      }\n"
"    }\n"
"    if (finalPaths.count>1 && finalPaths[0] == \"/\") finalPaths[0] = \"\"\n"
"    var path = finalPaths.join(sep)\n"
"    if (path == \"\") path = \".\"\n"
"    return Path.new(path)\n"
"  }\n"
"}";

// Generated automatically from src/cli/*.wren. Do not edit.
static const char* wren_packageModuleSource =
"import \"io\" for Directory\n"
"import \"os\" for Process\n"
"\n"
"class Color {\n"
"  static GREEN { \"\\u001b[32m\" }\n"
"  static RED { \"\\u001b[31m\" }\n"
"  static BOLD { \"\\u001b[1m\" }\n"
"  static RESET { \"\\u001b[0m\" }\n"
"}\n"
"\n"
"class Dependency {\n"
"  construct new(name, version, source) {\n"
"    _name = name\n"
"    _version = version\n"
"    _source = source\n"
"  }\n"
"  name { _name }\n"
"  version { _version }\n"
"  source { _source }\n"
"}\n"
"\n"
"class Runner {\n"
"  construct new() {\n"
"    _jobs = []\n"
"  }\n"
"  add(cmd, args) { add(cmd,args,null) }\n"
"  add(cmd, args, path) {\n"
"    _jobs.add([cmd,args,path])\n"
"  }\n"
"  run(cmd, args) { run(cmd,args,null) }\n"
"  run(cmd, args, cwd) {\n"
"    var result\n"
"    System.print(\" - [R] %(cmd) \" + args.join(\" \"))\n"
"    return Process.exec(cmd, args, cwd)\n"
"  }\n"
"  go() {\n"
"    _jobs.each { |job|\n"
"      var r = run(job[0], job[1], job[2])\n"
"      if (r!=0) {\n"
"        Fiber.abort(\" - FAILED (got error code %(r))\")\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"var ShowVersion = Fn.new() {\n"
"  System.print(\"wren-package v0.2.0 (embedded)\")\n"
"}\n"
"\n"
"class WrenPackage {\n"
"  construct new() {}\n"
"  dependencies() {}\n"
"  name { \"package\" }\n"
"  list() {\n"
"    System.print(\"%(name) dependencies:\")\n"
"    dependencies.each { |dep|\n"
"      System.print(\"- %(dep.name) %(dep.version)\")\n"
"    }\n"
"  }\n"
"  default() {\n"
"    if ([\"[-v]\",\"[--version]\"].contains(Process.arguments.toString)) {\n"
"      ShowVersion.call()\n"
"    } else if (Process.arguments.toString == \"[install]\") {\n"
"      install()\n"
"    } else {\n"
"      System.print(\"Usage:\\n./package.wren install\\n\")\n"
"      list()\n"
"    }\n"
"  }\n"
"  install() {\n"
"    if (!Directory.exists(\"wren_modules\")) Directory.create(\"wren_modules\")\n"
"    dependencies.each { |dep|\n"
"        System.print(\" - installing %(dep.name) %(dep.version)\")\n"
"      if (Directory.exists(\"wren_modules/%(dep.name)\")) {\n"
"        System.print(\" - %(dep.name) already installed. To reinstall, remove first.\")\n"
"        // Process.exec(\"git\", [\"fetch\",\"--all\"], \"wren_modules/%(dep.name)\")\n"
"        // Process.exec(\"git\", [\"checkout\", dep.version], \"wren_modules/%(dep.name)\")\n"
"      } else {\n"
"        // var args = [\"clone\",\"-q\",\"-b\", dep.version,dep.source, \"wren_modules/%(dep.name)\"]\n"
"        var run=Runner.new()\n"
"        run.add(\"git\", [\"clone\",\"-q\",dep.source,\"wren_modules/%(dep.name)\"])\n"
"        run.add(\"git\",[\"checkout\", \"--detach\", dep.version], \"wren_modules/%(dep.name)\")\n"
"        var f = Fiber.new { run.go() }\n"
"        f.try()\n"
"        if (f.error != null) {\n"
"          System.print(\" - Could not install dependency %(dep.name) %(dep.version)\")\n"
"          System.print(\" * %(dependencies.count) dependency(s). %(Color.RED)Failed to install.%(Color.RESET)\")\n"
"          Process.exit(1)\n"
"        }\n"
"      }\n"
"    }\n"
"    System.print(\" * %(dependencies.count) dependency(s). %(Color.GREEN)All good.%(Color.RESET)\")\n"
"  }\n"
"}";

// Generated automatically from src/cli/*.wren. Do not edit.
static const char* boogerModuleSource =
"class Booger {\n"
"  \n"
"}";

